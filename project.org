* Plan

* To Do

** jump-thread can coalesce blocks
   if a block has a single predecessor and that predecessor
   has a single successor, and the exception regions are
   the same, then the blocks can be merged

** Currently we don't handle special-variable-p in let bindings
   Major bug!

*** We have to transform (let ((*V* value)) BODY)
    Probably need to introduce a new "internal function" for this;
    the "obvious" transform using unwind-protect doesn't actually 
    follow elisp semantics.

    Maybe something like:

        (let ((--n-- (:specpdl:)))
	  (unwind-protect
	      (:specbind: *V* value)
	    (unbind-to --n--)))

    Ditto for let* of course

** Some special forms are still not handled

** "Ordinary special forms"

    (let ((result nil))
      (mapatoms (lambda (sym)
		  (when (special-form-p (symbol-function sym))
		    (push sym result))))
      result)

*** (track-mouse defconst defvar save-excursion setq-default 
     interactive save-restriction save-current-buffer function)

*** These require CFG improvements, probably Factored CFG
**** catch
**** throw
**** signal
**** condition-case
**** unwind-protect

*** need a special block-terminator to follow signal, throw
*** need to mark error, others as noreturn ?
*** can turn throw->catch into a goto

    (catch CONST (... (throw CONST val)))
    =>
    R = val; GOTO done

    However this has to deal with unwind-protect as well

** If a value is ignored we still emit a temporary
   Sometimes a value is only needed as a boolean, like (if (and ...)).
   This could be optimized as well

** Probably need more passes, pass infrastructure, SSA, type inference, etc

** Various code-gen bits need thinking through

* Passes

** Note that we can copy-propagate into a funcall or apply
   For apply this is a bit like strength reduction

** Type inference, including handling type predicates

* Emacs Bugs

** Some code uses the CLASS-child-p form, since the CLASS-p form didn't seem to work.

** There doesn't seem to be a way to fetch an object's name
   (there is - you can inherit from eieio-named)

** concat and mapconcat don't allow characters
   this seems unfriendly and pointless

** vc-dir "i" gives an unhelpful error if any other file is marked
   this seems somewhat useless

** it seems strange for elisp to have both defstruct and defclass
   given that it isn't really planning to be CL

** it seems that cl-nreconc would be more efficient as
   (prog1 (nreverse x) (setcdr x y))
