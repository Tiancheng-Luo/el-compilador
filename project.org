* Plan

* To Do

** bug with unbinding
   we need to add a fake unwind-protect edge
   so the `catch' optimization doesn't skip unbinds

** Remove "defuns" from compiler?

** It's easy to see dumb code like

   set G5030_5031 = argument arg
   return G5030_5031

   we'll optimize that away (eventually) but it would be nice perhaps
   not to generate it in the first place

** We don't handle lambdas at all

** Need to do closure-conversion

*** Probably need to handle "closure"

** Some special forms are still not handled

** "Ordinary special forms"

    (let ((result nil))
      (mapatoms (lambda (sym)
		  (when (special-form-p (symbol-function sym))
		    (push sym result))))
      result)

*** (defconst defvar save-excursion
     interactive save-restriction save-current-buffer function)

*** (Note track-mouse turned into a macro)

*** Some of these can be handled by unwind-protect plus an internal function

** can turn throw->catch into a goto

    (catch CONST (... (throw CONST val)))
    =>
    R = val; GOTO done

    We do this already but can do better by handling unwind-protect as
    well

* Passes

** Copy and constant propagation
   Perhaps SCCP - we can reuse the idea for type inference

** Note that we can copy-propagate into a funcall or apply
   For apply this is a bit like strength reduction

** Type inference, including handling type predicates

** Can we always optimize mapc and mapcar with a lambda?
   If we add a compiler macro can it expand back to 'itself'?

** We can optimize some regexps.
   for example looking-at-p with a constant can be turned into ordinary code
   especially if the regexp is very simple this would be a win
   same with string-match-p

** At least a simple form of TCO is easy

** Look into a smarter form of closure conversion
   Possibly sometimes we could optimize away closed-over variables, etc

* Back Ends

** Disassembly

** C Code

*** Could use Aur√©lien's "FFI" / DSO thing

*** Type inference would be great here, could do unboxing

** Bytecode

* Emacs Bugs

** Some code uses the CLASS-child-p form, since the CLASS-p form didn't seem to work.

** There doesn't seem to be a way to fetch an object's name
   (there is - you can inherit from eieio-named)

** concat and mapconcat don't allow characters
   this seems unfriendly and pointless

** vc-dir "i" gives an unhelpful error if any other file is marked
   this seems somewhat useless

** it seems strange for elisp to have both defstruct and defclass
   given that it isn't really planning to be CL

** it seems that cl-nreconc would be more efficient as
   (prog1 (nreverse x) (setcdr x y))
   ... not if x=nil?

** I wonder if progv is implemented correctly now that
   macroexpand is done eagerly
