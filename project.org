* Plan

* To Do

** into-ssa is still a bit broken
   arguments need to be turned into ssa form but are not

** DCE might be a bit broken
   it's hard to tell due to the into-ssa bug

** The variable from a `catch' or `unwind-protect' has to be
   kept in the handling block
   it can just be a special call

** Currently we don't handle special-variable-p in let bindings
   Major bug!

*** We have to transform (let ((*V* value)) BODY)
    Probably need to introduce a new "internal function" for this;
    the "obvious" transform using unwind-protect doesn't actually 
    follow elisp semantics.

    Maybe something like:

        (let ((--n-- (:specpdl:)))
	  (unwind-protect
	      (:specbind: *V* value)
	    (unbind-to --n--)))

    Ditto for let* of course

** For a special variable we do not want to use a `set' instruction.
   These should be reserved for ssa names
   Instead we should use a `call' with `setq'
   This would negate the comment below about needing a temporary
   result from a setq

** Some special forms are still not handled

** "Ordinary special forms"

    (let ((result nil))
      (mapatoms (lambda (sym)
		  (when (special-form-p (symbol-function sym))
		    (push sym result))))
      result)

*** (track-mouse defconst defvar save-excursion setq-default 
     interactive save-restriction save-current-buffer function)

*** Some of these can be handled by unwind-protect plus an internal function

** can turn throw->catch into a goto

    (catch CONST (... (throw CONST val)))
    =>
    R = val; GOTO done

    We do this already but can do better by handling unwind-protect as
    well

** If a value is ignored we still emit a temporary
   Sometimes a value is only needed as a boolean, like (if (and ...)).
   This could be optimized as well

** If we use the result of setq we generate an extra load
   However we could avoid this by using a private name for
   the intermediate set
   Or maybe it won't matter at all after ssa opts

* Passes

** Still need to write into-SSA

** Note that we can copy-propagate into a funcall or apply
   For apply this is a bit like strength reduction

** Type inference, including handling type predicates

** Can we always optimize mapc and mapcar with a lambda?
   If we add a compiler macro can it expand back to 'itself'?

* Back Ends

** Disassembly

** C Code

*** Could use the coming "FFI" / DSO thing

*** Type inference would be great here, could do unboxing

** Bytecode

* Emacs Bugs

** Some code uses the CLASS-child-p form, since the CLASS-p form didn't seem to work.

** There doesn't seem to be a way to fetch an object's name
   (there is - you can inherit from eieio-named)

** concat and mapconcat don't allow characters
   this seems unfriendly and pointless

** vc-dir "i" gives an unhelpful error if any other file is marked
   this seems somewhat useless

** it seems strange for elisp to have both defstruct and defclass
   given that it isn't really planning to be CL

** it seems that cl-nreconc would be more efficient as
   (prog1 (nreverse x) (setcdr x y))
   ... not if x=nil?

** I wonder if progv is implemented correctly now that
   macroexpand is done eagerly
