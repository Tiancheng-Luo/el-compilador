* Plan

* To Do

** stop using oref and oset and instead use accessors

** A "catch" with a non-constant tag will still require
   special handling in the IR, e.g. when converting to SSA form
   this isn't done now

** We can merge blocks with different exception handlers
   if one of them doesn't have any throwing instructions
   likewise if we have fake-unwind-protect?

** We can remove specbind/unbind if there aren't intervening statements
   probably unimportant optimization though?

** Can specbind or unbind throw?

** Remove "defuns" from compiler?

** It's easy to see dumb code like

   set G5030_5031 = argument arg
   return G5030_5031

   we'll optimize that away (eventually) but it would be nice perhaps
   not to generate it in the first place

** We don't handle lambdas at all

** Need to do closure-conversion

*** Probably need to handle "closure"

** Some special forms are still not handled

** "Ordinary special forms"

    (let ((result nil))
      (mapatoms (lambda (sym)
		  (when (special-form-p (symbol-function sym))
		    (push sym result))))
      result)

*** (defconst defvar save-excursion
     interactive save-restriction save-current-buffer function)

*** (Note track-mouse turned into a macro)

*** Some of these can be handled by unwind-protect plus an internal function

** can turn throw->catch into a goto

    (catch CONST (... (throw CONST val)))
    =>
    R = val; GOTO done

    We do this already but can do better by handling unwind-protect as
    well

* Passes

** SCCP pass

** GVN pass

** Note that we can copy-propagate into a funcall or apply
   For apply this is a bit like strength reduction

** Can we always optimize mapc and mapcar with a lambda?
   If we add a compiler macro can it expand back to 'itself'?

** We can optimize some regexps.
   for example looking-at-p with a constant can be turned into ordinary code
   especially if the regexp is very simple this would be a win
   same with string-match-p

** At least a simple form of TCO is easy

** Look into a smarter form of closure conversion
   Possibly sometimes we could optimize away closed-over variables, etc

** We could convert `elt' to aref or nth if we deduced the type
   We could perhaps inline nth and nthcdr if the argument is a constant

* Back Ends

** Disassembly

** C Code

*** Could use Aur√©lien's "FFI" / DSO thing

*** Type inference would be great here, could do unboxing

** Bytecode

* Emacs Bugs

** We should turn `nlistp' into a defsubst

** There's no way to recapture the fact that some CL 'throw' constructs
   are lexical

** Some code uses the CLASS-child-p form, since the CLASS-p form didn't seem to work.

** There doesn't seem to be a way to fetch an object's name
   (there is - you can inherit from eieio-named)

** concat and mapconcat don't allow characters
   this seems unfriendly and pointless

** vc-dir "i" gives an unhelpful error if any other file is marked
   this seems somewhat useless

** it seems strange for elisp to have both defstruct and defclass
   given that it isn't really planning to be CL

** it seems that cl-nreconc would be more efficient as
   (prog1 (nreverse x) (setcdr x y))
   ... not if x=nil?

** I wonder if progv is implemented correctly now that
   macroexpand is done eagerly
